<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art Gallery</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://cdn.cdt.ca.gov/cdt/statetemplate/6.3.2/css/cagov.core.css" rel="stylesheet" integrity="sha256-kDYMlt+egSpUJHbZGlUHIGRh0b/TYdUgp/x1OnFJw0M=" crossorigin="anonymous">
    <link href="https://cdn.cdt.ca.gov/cdt/statetemplate/6.3.2/css/colortheme-oceanside.css" rel="stylesheet"  integrity="sha256-PC5Yszm8bAjYYFmjeL8EeB8mHo+S4dJbQt4OwA4aTmg=" crossorigin="anonymous">
    <link rel="stylesheet" href="css/index.css">
    <script type="text/javascript">window.PlotlyConfig = {MathJaxConfig: 'local'};</script>
    <script charset="utf-8" src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>     
</head>

<body>
    <img src="images/background.gif" alt="" id="background">
    <div class="main">

        <h2 id="relat-rio-problema-da-galeria-de-arte">Problema da Galeria de Arte</h2>
        <p><b> Autores: </b> Antônio Caetano Neves Neto, Beatriz Reis Gama Barbosa, João Lucas Simões Moreira.</p>
        <h1 id="introdu-o">Contextualização</h1>
        <p> O problema da galeria de arte consiste na decisão do número mínimo de câmeras necessárias para vigiar uma área - dada por um polígono -, 
        além do posicionamento das câmeras em questão. A solução empregada foi o desenvolvimento de dois algoritmos distintos: o <b> 
        algoritmo do corte de orelhas </b>, feito para dividir em triângulos o polígono de entrada, e o <b> algoritmo da 3-coloração </b>, que
        foi construído sobre o grafo dual do polígono triangulado e usado para decidir onde posicionar cada câmera necessária. 
        A quantidade total de câmeras é ⌊n/3⌋, onde n é o número de triângulos formados, o que será explicado na etapa de coloração.</p>

        <h1 id="metodologia-complexidade">Metodologia &amp; complexidade</h1>
        <p>Para esta seção, serão descritas as implementações de cada um dos algoritmos citados na contextualização.</p>
        <ol>
            <li>
                Corte de orelhas
            </li>
            O algoritmo do corte de orelhas é uma técnica para realizar a triangulação de um  polígono dado, ou seja, transformar um polígono 
            convexo em uma composição de diferentes triângulos. Um exemplo de triangulação pode ser visto na imagem a seguir. <br>
            <div align="center">
                <img src="../imgs/triangulacao_dark.jpeg" id="normal"/>
            </div>
            <p align="center">Figura 1: À esquerda, o polígono de entrada, e à direita, o polígono triangulado.</p>
            Para realizar essa técnica, foi necessário desenvolver algumas funções auxiliares:
            <ul>
                <li>Função <i>is_convex(a, b, c)</i>: necessária para determinar se o polígono formado pelos pontos a, b
                    e c
                    é convexo ou não; </li>
                <li>Função <i>is_in_triangle(a, b, c, p)</i>: necessária para determinar se havia algum ponto p dentro
                    de um
                    triângulo a, b, c formado;</li>
                <li>Função <i>is_clock_wise(polygon)</i>: necessária para verificar se os pontos do polígono estão em sentido horário;
                </li>
            </ul>
            <br>
            A função principal, chamada <i>get_unique_ear(polygon, n_frames)</i> recebe pontos do polígono de entrada e
            um
            valor que representa o número de frames necessários para a animação, e retorna o primeiro triângulo
            detectado no
            polígono. Primeiramente, se descobre o tamanho da entrada; caso existam menos de 3 pontos, não é possível
            realizar a triangulação. Se ela possuir somente 3 pontos, a triangulação é o próprio polígono. Caso possua
            mais,
            então é feita uma iteração sobre a entrada, pegando 3 pontos a cada vez. Em seguida, é avaliado se esses 3
            pontos formam um polígono convexo, e se sim, é checado se não existem pontos dentro desse polígono. Caso
            ambas
            as condições forem válidas, então os três pontos são deletados e o polígono é salvo. <br>
            O processo de animação corre em um loop que chama sucessivamente a <i>get_unique_ear</i> até que não haja
            mais
            opções de triângulos a serem formados. A cada iteração, é exibido o polígono inteiro e o triângulo que está
            sendo avaliado (em amarelo). Se ele for um triângulo válido, ele é adicionado ao polígono inteiro. A
            complexidade desse algoritmo é quadrática, pois, para cada triângulo formado, é necessário avaliar se existe
            algum ponto entre os demais que está dentro dele. O vídeo com esse processo pode ser visto abaixo.
            <!-- <div align="center">
                <img src = "../imgs/triangulacao.gif"/>
            </div> -->
            <br>
            <select id="selector" onchange="showTriangulationDiv(event)">
                <option value="div1-triangulation">Triangulação 1</option>
                <option value="div2-triangulation">Triangulação 2</option>
                <option value="div3-triangulation">Triangulação 3</option>
            </select>

            <div id="div1-triangulation" class="animation-triangulation-div">
                <div id="e88ae352-33eb-45d5-b9e4-7db300c4af87" class="plotly-graph-div"></div>
            </div>
            
            <div id="div2-triangulation" class="animation-triangulation-div">
                <div id="e88ae352-33eb-45d5-b9e4-7db300c4af87" class="plotly-graph-div"></div>
            </div>
            
            <div id="div3-triangulation" class="animation-triangulation-div">
                <div id="e88ae352-33eb-45d5-b9e4-7db300c4af87" class="plotly-graph-div"></div>
            </div>

            <script>
                function showTriangulationDiv(event) {
                    // Esconde todas as divs
                    const selectedValue = event.target.value;

                    const divs = document.querySelectorAll('.animation-triangulation-div');
                    divs.forEach(div => div.style.display = 'none');

                    // Mostra a div correspondente
                    if (selectedValue) {
                        document.getElementById(selectedValue).style.display = 'flex';
                    }
                }
            </script>
            <p align=" center">Figura 2: Animação da triangulação.</p>
            <br>

            <li>
                3-Coloração
            </li>
            O algoritmo da 3-coloração foi utilizado sobre uma instância de grafo que pode ser resolvida em
            tempo polinomial, apesar de o problema ser conhecidamente NP. Para gerar esse grafo, é necessário
            transformar o polígono triangulado utilizando as seguintes regras:
            <ul>
                <li>Vértices: cada triângulo do polígono se torna um vértice; </li>
                <li>Arestas: se dois triângulos compartilham uma aresta, então existirá uma aresta entre eles no
                    grafo gerado.</li>
            </ul>
            <div align="center">
                <img src="../imgs/dual_dark.jpeg" id="normal"/>
            </div>
                <p align="center">Figura 3: Processo de construção do grafo dual ao polígono de entrada.</p>
                <br> Com isso, é gerado um grafo dual ao polígono, conexo, que corresponde a uma árvore. Com ele,
                podemos realizar uma busca em profundidade (DFS), e cada vértice será visitado apenas uma vez. Para
                cada nó explorado, é feita a coloração de seus 3 vértices associados no polígono triangulado. Como a cpmplexidade da DFS
                é proporcional ao número de arestas no grafo dual, a 3-coloração é feita em tempo linear. Os vídeos
                com os  processos descritos (tanto da DFS quanto da coloração) podem ser vistos abaixo.
                <div align="center">
                    <img src="../imgs/dfs.gif" id="normal"/>
                </div>
                <p align="center">Figura 4: Animação da DFS. Em branco, estão os vértices ainda não descobertos pela busca, em cinza os descobertos
                e em preto aqueles nos quais a busca foi finalizada.</p>
                <select id="selector" onchange="showColoringDiv(event)">
                    <option value="div1-coloring">Coloração 1</option>
                    <option value="div2-coloring">Coloração 2</option>
                    <option value="div3-coloring">Coloração 3</option>
                </select>
                <br>
                <div id = "div1-coloring" class = "animation-coloring-div">
                    <div id = "6b10d88c-f060-4552-a43c-f474e5af59ef" class = "plotly-graph-div"></div>
                </div>
                <div id = "div2-coloring" class = "animation-coloring-div">
                    <div id = "0d6809ec-831f-4949-8457-1c59d3bd77cd" class = "plotly-graph-div"></div>
                </div>
                <div id = "div3-coloring" class = "animation-coloring-div">
                    <div id = "6b10d88c-f060-4552-a43c-f474e5af59ef" class = "plotly-graph-div"></div>
                </div>
                <script>        
                    const divs = document.querySelectorAll('.animation-coloring-div');
                    divs.forEach(div => div.style.display = 'none');            
                    document.getElementById('div1-coloring').style.display = 'flex';
                </script>
                <script>
                    function showColoringDiv(event) {
                        const selectedValue = event.target.value;

                        const divs = document.querySelectorAll('.animation-coloring-div');
                        divs.forEach(div => div.style.display = 'none');

                        if (selectedValue) {
                            document.getElementById(selectedValue).style.display = 'flex';
                        }
                    }
            </script>
            <!-- <div align="center">
                <img src="../imgs/coloracao.gif" id="normal"/>
            </div> -->
            <p align="center">Figura 5: Animação da coloração.</p>
        </ol>

        <h1 id="conclus-o">Conclusão</h1>
        <p>Assim, a partir da 3-coloração dos n triângulos, podemos concluir que a quantidade de câmeras necessárias
            para cobrir o polígono é ⌊n/3⌋, uma vez que basta posicioná-las nos vértices de uma única cor. Uma vez que queremos minimizar
            a quantidade de câmeras, escolhemos a cor menos frequente na 3-coloração. 
            Na Figura 6, podemos ver a disposição das câmeras no polígono de exemplo.</p>
        <p>
        <div align="center">
            <img src="../imgs/cameras_dark.jpeg" id="normal"/>
        </div>
        </p>
        <p align="center">Figura 6: Disposição das câmeras.</p>

        <h1 id="bibliografias">Bibliografia</h1>
        <ul>
            <li>Computational Geometry in C, 2nd ed., J. O’Rourke</li>
            <li>Cormen, T. H., Leiserson, C. E., &amp; Rivest, R. L. (1990). Introduction to algorithms.</li>
            <li>Slides da disciplina de Algoritmos 2</li>
        </ul>

    </div>

    <script src="animation/triangulation1.js"></script>   
    <script src="animation/triangulation2.js"></script>
    <script src="animation/triangulation3.js"></script>
    <script src="animation/coloring1.js"></script>   
    <script src="animation/coloring2.js"></script>
    <script src="animation/coloring3.js"></script>
</body>
</html>